## Go笔记



- [Goroutine](#Goroutine)

### 服务容器

依赖，指的是一个类 A 的变化会引起另一个类 B 的变化

解决依赖是通过将对象以参数的形式传入，这就叫做 **依赖注入**

这个过程是控制反转，谁控制谁，又改变成谁控制谁

在应用程序自身的作用域调用，那么是





### 通道（channel）

通道（Channel） 是 Go 语言中一种用于在不同 goroutine 之间传递数据的机制。通道是一种类型安全的数据传输管道，**可以在不同的 goroutine 之间传递消息，实现同步和通信**。

通道是 Go 语言并发编程的核心概念之一，它提供了一种安全、简洁的方式来管理 goroutine 之间的数据共享。与传统的多线程编程不同，Go 鼓励通过通道来共享内存，而不是通过共享内存来实现通信。

#### 通道的基本概念

**1. 通道类型**：通道是一种类型化的管道，通道的类型决定了它可以传输的数据类型。声明通道时需要指定它传输的数据类型，例如：`chan int` 表示一个传输 `int` 类型数据的通道。

**2. 创建通道**：使用内置的 `make` 函数创建一个通道。语法如下：

```go
ch := make(chan int) // 创建一个传输 int 类型的无缓冲通道
```

**3. 发送和接收操作**：

- **发送数据到通道**：使用 `<-` 操作符将数据发送到通道。

  ```
  ch <- 1 // 将整数 1 发送到通道 ch
  ```

- **从通道接收数据**：使用 `<-` 操作符从通道接收数据。

  ```
  value := <-ch // 从通道 ch 接收数据并赋值给变量 value
  ```

**4. 无缓冲通道**：一个无缓冲通道在没有接收方接收数据之前，发送方会被阻塞；同样地，接收方在没有发送方发送数据之前也会被阻塞。因此，无缓冲通道确保了发送和接收操作是同步的。

**5. 缓冲通道**：带有缓冲区的通道可以存储一定数量的数据。在创建通道时，可以通过第二个参数指定通道的缓冲区大小，例如：`make(chan int, 2)` 创建一个缓冲区大小为 2 的通道。带有缓冲区的通道在缓冲区未满时不会阻塞发送操作，在缓冲区非空时不会阻塞接收操作。

#### 通道的简单使用示例

以下是一个简单的示例，演示了通道的创建、发送和接收操作：

```go
package main

import "fmt"

func main() {
    // 创建一个无缓冲通道
    ch := make(chan int)

    // 启动一个 goroutine 来发送数据
    go func() {
        ch <- 42 // 发送数据到通道
    }()

    // 从通道接收数据
    value := <-ch
    fmt.Println("Received:", value) // 输出: Received: 42
}
```

#### 通道的特性

通道非常适用于以下几种场景：

1. **goroutine 之间的通信**：在多个 goroutine 之间传递数据，避免竞争条件。
2. **任务分发和结果收集**：用于任务生产者和消费者模式，任务可以在不同的 goroutine 之间传递。
3. **同步控制**：通过无缓冲通道实现多个 goroutine 之间的同步。

#### 总结

通道（channel）是 Go 语言提供的一种强大而灵活的并发工具，它允许不同的 goroutine 安全地进行数据交换，避免了直接使用共享内存可能带来的竞争条件和死锁问题。使用通道编写并发程序既简洁又安全，充分体现了 Go 语言的并发编程理念——“不要通过共享内存来通信，而是通过通信来共享内存”。

#### 练习

1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
   1. 通道是一个串行队列，顺序是先进先出
   
   2. 通道具有原子性，只有一个goroutine能够对某一个通道进行取出操作，其他的试图对这个通道进行取出操作的goroutine都会被阻塞，并进入通道内部的队列排队。通道会保证这种操作是互斥的。
   
      MySQL 保证原子性，是使用读写锁实现乐观锁或者悲观锁
   
      Redis 保证原子性，因为Redis本身就是单线程的，所以执行单个命令都是按顺序执行的，而多个命令保证原子性，可以通过事务并且使用 `WATCH` 监听键是否有修改，来判断是否提交事务，实现了乐观锁的方式
      
      redis提供了setnx方法，因为redis本身是串行执行的，使用setnx方法去看有没有占用，他有一个稍微要注意，如果用setnx去抢占一个锁的话，抢锁是不会有什么问题，在释放锁的时候，执行完了，这个锁就过期了，delete的是别人的锁，所以redlock的话，他在value是生成了一个唯一字符串，他最后释放这个锁的时候使用的是lua的脚本，他会拿出key的value值跟当时记录的值是不是一致的，如果是一致的那么就删，如果不一致那么就是自然过期了，被别人抢占到了，那么就是别人的锁，这个时候就不能删了
      
      redis是拆分成很多小实例，他们都是主从，比如是多个服务，每个服务有自己的redis
      
      那你了解过主从模式和集群模式的区别吗
      
      主从模式就是当主redis挂了会自动切换到从模式上



1. 发送操作和接收操作中对元素值的处理都是不可分割的。

2. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

   

### Goroutine

Goroutine 可以理解为是 Go 语言的协程（轻量级协程），是 Go 语言中提供并发处理的方式，属于用户态的线程，由 Go runtime管理而不是操作系统。



#### 底层数据结构

Goroutine 本质上是底层的一个数据结构，它实现了一个类似内核线程的效果，因为他的底层内部结构存储了比如上下文，栈，以及调用goroutine的入口函数，还有一个当前goroutine的这个函数的一个地址

线程可以通过调度系统独立管理的最小程序指令集，而进程是程序运行的实例



```go
type g struct {
    goid    int64 // 唯一的goroutine的ID
    sched gobuf // goroutine切换时，用于保存g的上下文
    stack stack // 栈
    gopc        // pc of go statement that created this goroutine
    startpc    uintptr // pc of goroutine function
    ...
}

type gobuf struct {
    sp   uintptr // 栈指针位置
    pc   uintptr // 运行到的程序位置
    g    guintptr // 指向 goroutine
    ret  uintptr  // 保存系统调用的返回值
    ...
}

type stack struct {
    lo uintptr // 栈的下界内存地址
    hi uintptr // 栈的上界内存地址
}

```



#### 并发和并行

在数字计算机的整个历史中，有两个需求是驱动进步的持续动力：

1. 想要计算机做的更多
2. 想要计算机运行得更快

当处理器能够同事做更多的事情时，这两个因素都会改进。



并发（concurrency）一段时间内执行多个任务，这意味着仅需一个物理核心，也就是一个cpu就能实现。

并行（parallelism）同一时刻执行多个任务，这意味着至少需要2个物理核心才能实现。



比如一个CPU有两个物理核心，core-1、core-2，有三个任务ABC，这些任务被分成若干个时间片，时间片1-10，

情况一：多个时间片在一个物理核心上运行，这意味着并发运行

情况一：多个时间片在两个物理核心上同一时刻运行，则为并行运行



一个CPU只有一个物理核心，有三个任务ABC，这些任务被分成若干个时间片，大约分为5-10个，分别依次执行，会出现如下情况，在任务A和任务B还没完全执行完就被移出了，在后面的时间片又被加载执行。























### GC

#### 什么是gc

是内存管理的垃圾回收机制，内存,防止内存泄漏，go语言是三色标记法，从一个根节点开始查找一条路径，标记灰色，再从标记灰色的对象扩展查找，而第三次查找到的标记黑色，类似于一种宽度优先算法，先访问当前节点的所有邻接节点，在访问下一层，目的是为了找到可达对象和不可达对象，将不可达的对象进行回收

垃圾回收机制是处理堆内存的回收，栈内存是指变量的生命周期只是在局部作用域中，那么在函数返回时会自动回收，而堆内存是指变量的生命周期超过了作用域，也就是引用使用，那么这个变量的内存就会逃逸到堆上

在项目中大量重复地创建许多对象，会造成GC的工作量巨大，CPU频繁升高，可以使用sync.Pool来缓存对象，他可以作为一个对象缓冲池，在并发线程的使用中，这个对象缓冲池是共享内存的，

Pool的数据类型提供了三个api，New Get Put，开发时设置好New就可以了，在使用时使用Get获取对象，再Put回池里，供下一个线程调用，有一个要注意的是再Put时需要将对象清空，避免数据出错





### 容器

#### cgroup

容器技术是基于cgroup机制，来限制进程和资源的
memory子系统，memory.limit_in_bytes，用来控制进程最多能用多少内存开销的这样一个配置

操作系统里的资源，像CPU这种资源是可压缩资源，什么是可压缩资源，就是说虽然我这个进程很忙，它可能要两个CPU，但是我给他0.1个CPU也可以，它慢慢转就行了，只不过会变慢，但内存不一样，比如说一个进程需要10个G的内存，我给压制成1个G，那么它新的内存申请就申请不出来了，这个时候程序就出现问题了，所以对于这个非压榨资源，操作系统所处理的行为也是不一样的，所以，当我们使用了memory的subsystem，通过limit_in_bytes去限制了一个进程的内存资源的时候，达到了这个限制以后，这个程序不能再继续运行了，那么这个系统会有一个配
置文件memory.oom_control，它的默认行为就是OOM Killer，就会直接把这个进程杀死，让他重新启动，所以这是内存子系统跟CPU子系统的主要差异，当然这个杀死进程行为可以改写

cgroup就是通过一系列的配置文件来管控所有的资源分配的，包括我创建了一个cpu，我把一个进程号和cpu产生了一个关联关系，把进程放到了那个procs文件里面，我同时去修改CPU的quota （考它）来限制他的资源，那么这一整套都是cgroup系统，但是cgroup本身可以有不同的driver，比如说docker，它用的是cgroupfs作为驱动，整个操作系统，它用的是systemd的cgroup drive，所以当我们用kubernetes的时候，这两者要统一，systemd拉起的进程是通过systemd 的这套系统去管控的，那docker拉起的进程是docker cgroupfs这套系统去管控的，那么就会出现一鱼两吃的情况，就是你同一套资源，被两套系统往外分啊，当这种系统异常压力大就会出现不必要的问题，当使用kubernetes的时候会去做检查，他会在启动的时候，去判断docker用了哪一个cgroup driver，如果发现docker本身用systemd。他就会默认报错不启动，



### 错误处理

#### Error

`error` 是一个标准库的接口类型，它定义了一个 `Error()` 方法，返回一个描述信息的字符串



#### 自定义错误类型

自定义实际业务需求的结构体类型，实现标准库 error 的接口。



#### panic

内置函数，用于中断当前goroutine的执行，有被动中断，和主动中断，，比如索引越界，空指针访问，主动抛出异常



#### recover

内置函数，用于恢复异常的程序，防止系统崩溃，一般和panic一起使用



#### defer

关键字，用来延迟执行代码的，延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么，比如有panic、return之后



#### 使用示例

```go
package main

import (
	"errors"
	"fmt"
)

func main() {
	fmt.Println("Enter function main.")
	defer func() {
		fmt.Println("Enter defer function.")
		if p := recover(); p != nil {
			fmt.Printf("panic: %s\n", p)
		}
		fmt.Println("Exit defer function.")
	}()
	// 引发panic。
	panic(errors.New("something wrong"))
	fmt.Println("Exit function main.")
}
```



#### try-catch 和 defer-recover 的理解

**try-catch**

java的异常分为受检异常与非受检异常

受检异常：会在编译时被检查处理（强制处理），这些异常为了程序比如有文件系统错误，网络错误等，保持程序的健壮性

非受检异常是在运行时抛出，不强制处理



go的异常处理是显式的，它更多的是把可预期的错误和异常分开，避免异常被滥用

我觉得他们两个更多的是一种，协作者和控制者身份的区别





### GMP 模型

GMP是go运行时负责调度器，是将go协程，绑定要具体的线程上执行的过程，他分别由gorutine 协程，machine 实际的操作系统线程，processor 调度器组成

操作系统在调度的过程中会进行很多系统级的工作，所以在线程切换的代价比较高，除了线程的切换，如果函数级的切换，速度就会快很多

在应用程序的执行中会产生比如上万个线程，那么操作系统linux比如有8个cpu，那么对应八个线程，从产生上万个线程到cpu具体去执行，就需要想办法去映射到某一个线程去执行，这一层是通过调度地，也就是p去实现的，调度器去通过队列分发到具体的线程

调度器有正常模式和饥饿模式两种，正常模式是调度器从全局队列或者本地队列取出，并且只有本地队列为空时才从全局队列窃取，饥饿模式是当某些协程长时间得不到调度时，调度器会进入饥饿模式，优先调度这些被饿死的写成，确保他们能够尽快执行



### 微服务

谈一谈微服务的理解

#### 微服务的产生





### kafka

这种 一般牵涉到消息中间件 最常问的就是
1. 怎么保证消息一定可达
2. 消息错乱
3. 横向扩展
4. 数据不丢失、 重复消费（幂等）
5. 性能问题
6. 异常处理
7. 使用场景
8. 横向对比
9. 还有集群问题（集群安装、为啥3 以后不用zookeeper了）、为啥性能这么高（零拷贝）。。。
10. 面试 问的多的 一般会拿 kafka、rabbitmq。有一些还会拿rocketmq让你对比



redis的持久化是通过RDB快照和AOF日志相结合的形式，保证消息可达（不丢失），快照会间隔性的将数据从内存备份到磁盘里，AOF日志会记录所有对数据的写操作

kafka的持久化是将消息写入到日志中，也是间隔性的将数据从内存备份到磁盘里，他还有复制机制和ACK机制，复制机制是可以为每个Topic配置多个副本，如果某个节点宕机，消息也不会丢失，ACK机制是用于控制生产者发送消息时等待确认的级别，

分别是

1. 不等待消息确认
2. 等待消息写入
3. 等待消息写入并同步所有副本











使用以下命令查看系统允许的最大文件描述符数量：

cat /proc/sys/fs/file-max

查看当前用户限制

ulimit -n

hard limit不能大于`/proc/sys/fs/nr_open`





你可以从以下几个方面对 PHP-FPM 进行调优：

1. **`pm` 设置**：选择合适的进程管理模式（`static`、`dynamic`、`ondemand`）以优化资源使用。
2. **`pm.max_children`**：根据服务器的内存和负载，合理设置最大子进程数，以避免内存不足。
3. **`pm.start_servers`、`pm.min_spare_servers`、`pm.max_spare_servers`**：设置启动时的进程数和最小/最大空闲进程数，确保在高峰期有足够的可用进程。
4. **`request_terminate_timeout`**：设置请求的最大执行时间，防止长时间阻塞的请求。
5. **`slowlog`**：配置慢日志以识别性能瓶颈。







现在公司的规模不是很大，在这家公司其实是经历了从中级做到高级的过程，已经从边缘业务做到核心业务了，但是公司业务的限制对于技术的发展有瓶颈，想去一些更大的平台，寻找更多的发展



数组，存储相同类型的数据，访问/查询速度快



### new和make的区别

make和new都是内置函数，这两个内置函数的作用是为变量分配内存，变量初始化包括两步，变量声明+变量内存分配，var 关键字 就是用来声明变量的，new和make函数用于分配内存，比如 var 声明值类型的变量是，系统会默认为他分配内存空间，并赋予该类型的零值

比如布尔、数字、字符串、结构体

如果指针类型或者也叫引用类型的变量，系统不会为它分配内存，因为他代表了指针，指针的初始值就是 0x0 ，也就是nil，指针直接使用就会抛出异常，必须进行分配内存，才可以使用

区别：

使用场景：

make 只能用来分配及初始化类型为slice、map、chan的数据

new可以分配任意类型的数据，并且置零

返回值：

make函数返回的是类型本身

new函数返回指向该类型内存地址的指针



### Golang中数据类型的区分

#### 按存储方式

1. 值类型

   数据类型有 bool、string、数组、struct 结构体

   变量直接存储值，值类型的数据存储在栈内存空间，栈在函数调用完内存会被释放。

   数据类型有 bool、string、数组、struct 结构体

1. 引用数据类型

   数据类型有 指针、slice 切片、管道 chan、映射 map、接口 interface

   变量存储的是一个地址，这个地址最终存储值，引用数据类型的数据存储在堆内存空间中，通过GC回收







### Goroutine 什么时候会发生阻塞

Goroutine是Go语言中的轻量级线程，它们在Go运行时（runtime）中被调度和管理。Goroutine在以下几种情况下可能会发生阻塞：

- 阻塞在系统调用：当Goroutine执行一个阻塞的系统调用（如文件I/O、网络I/O等）时，它会被阻塞，直到系统调用完成。
- 阻塞在通道操作：Goroutine在执行通道（channel）操作时，如发送数据到一个已满的通道或从一个空的通道接收数据，可能会发生阻塞。阻塞会持续到通道中有足够的空间或数据可用。
- 阻塞在同步原语：Goroutine在等待锁（如sync.Mutex）或其他同步原语（如sync.WaitGroup）时，可能会发生阻塞。
- 阻塞在垃圾回收：在垃圾回收过程中，所有Goroutine都可能会短暂地被阻塞，以便垃圾回收器完成内存回收。





### 线上bug如何调试问题

线上有链路追踪，链路追踪就能看出大部分的问题了

OOM在做单体项目和PHP项目时遇到过，有时候内存会突然爆，那时候我们就是用性能分析，抓火焰图，抓他内存分布，go里好像可以用pprof抓到火焰图





### 项目中错误处理事怎么做的

项目有没有panic捕获，使用defer recover 捕获





因为我们用了grpc的服务，然后我们对自己定义了error对象，这样方便我们互相调用的时候通过grpc的error去透传error信息



用的是go-zero里的rpc框架，利用 grpc geteway，使用 etcd 进行相互调用，proto是怎么管理的，我们是放在一起的，是一个整体

etcd 我们用的是5节点，5节点，理论上除非整个机房断电，不然是不会挂的，raft算法是保证可靠性的



### go的错误处理

定义一个结构体，在tag里面去写需要验证的类型，使用的事shouldbind json 这个方法里通过反射校验



### 中间件

定义一个中间件，其实异常捕获也是可以做到中间件里的，如果说采用panic的方式往外抛的话

就可以在最外层定义中间件，然后定义defer recover 做一个全局的错误处理，当然也可以在这里做全局的日志打印





### 锁

使用读写锁的比较多，就比如map 应为map是协程不安全的，多个协程进行修改时是会报错的，在使用map的地方就可以加一个读写锁，在修改它之前lock起来，处理完之后释放，做到一个占用，防止并发修改，现在更多用的是sync.Map 是并发安全的，没有心智负担





哨兵模式和集群模式



string list zset set setnx



像zset用的比较多，在做排行榜的时候用的是zset



mysql 分库分表

mysql和redis也是使用的小实例



单个表很大，分表可以每个月创建一张表，或者说按照uid 按照16位 hash 除以16 分到16个表，目前单表还没有超过一个亿的都可以用





负载均衡算法





Etcd



### MySQL 锁

MySQl的锁定主要分为全局锁、表锁和行锁，加锁的目的，保证数据的一致性，防止数据错乱

#### 全局锁

###### 读锁（共享锁）

它阻止其他用户更新数据，但允许他们读取数据

###### 写锁（排他锁）

它阻止其他用户读取和更新数据。这在你需要修改一些大量的数据，并且不希望其他用户在这

MSQL全局锁的典型使用场景是，进行一些确保整个数据库一致性的操作，例如全库备份、全库导出等



##### 表锁

表级锁是MySQL中最基本的锁策略，是MySQL最早采用的锁策略，表级锁的特点是开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

表锁有两种模式

###### 表共享读锁

###### 表独占写锁

##### 行锁

###### 共享锁 读锁



###### 排他锁 写锁



























### 数据安全和风控

在微服务间登录，关于身份认证，数据交互使用 rsa 非对称加密，单点登录

SQL 注入 使用ORM框架对查询语句进行占位符查询

通过链路追踪

采集，对网站的数值进行图片加密

IP追踪，滑块验证码

数据库锁机制，限制频率













什么是通道

sync 锁有哪些，这些锁有什么区别

go-zero和gin框架的区别

协程是什么，说一下对协程的理解

redis和etcd的区别

kafka 和 redis 是如何实现发布订阅，他们两个的区别

kafka如何实现并发读写

sync.Map是如何实现的

阅读过redis的源码吗



