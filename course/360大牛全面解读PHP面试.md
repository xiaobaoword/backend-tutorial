## 前言

该文是对 `360大牛全面解读PHP面试`一课的笔记整理



## 参考资料

- [360大牛全面解读PHP面试](<https://coding.imooc.com/class/133.html>)

  

### 题库

#### 1. 运算符顺序考察
```
<?php
$a = 0;
$b = 0;

if ($a = 3 > 0 || $b = 3 > 0) {
	$a++; // true
	$b++; // 1 
	echo $a . "\n"; // 1
	echo $b . "\n"; // 1
}


# 运算符级别 '>' > '||' > '='
# 算后：$a = (3 > 0 || $b = 3 > 0) // true
```


#### 2. 请列出3中PHP数组循环操作的语法，并注明区别
```
<!--
    1. for
        计数型循环，只能遍历索引数组    
    2. foreach
        可以遍历索引和关联数组、会对数组进行reset()操作
    3. while、list()、each()组合
        可以遍历索引和关联数组、不会对数组进行reset()操作
-->
```

#### 3. 变量的作用域和静态变量
```
$count = 5;
function get_count()
{
    static $count; // 第一次初始化静态变量，之后不需要初始化
    return $count++; // 第一次返回5，第二次返回1
    
}
echo $count; // 5
++$count; // 6
echo get_count(); // NULL
echo get_count(); // 1

```

#### 4. 变量的作用域和静态变量
```

function &demo()
{
    static $b = 10;
    return $b;
}

$a = demo();
echo demo(); // 10

$a = &demo();
$a = 100;
echo demo(); // 100

```

#### 5. 系统内置函数
```

时间日期函数
    date()
    strtotime()
    mktime()
    time()
    microtime()
    date_default_timezone_set()
    
IP处理函数
    ip2long()
    long2ip

序列化及反序列化函数
    serialize()
    unserialize()
    
```

#### 6. 不断在hello.txt 头部写入一行 “Hello World” 字符串，要求代码完整
```
fopen()函数
# 用来打开一个文件，打开时需要制定打开模式
# 打开模式：r/r+、w/w+、a/a+、x/x+、b\t

名称相关：basename()、dirname()、pathinfo()
目录读取：opendir()、readdir()、closedir()、rewinddir()
目录删除：rmdir()
目录创建：mkdir()
文件大小：filesize()
目录大小：disk_free_space()、disk_total_space()
文件拷贝：copy()
删除文件：unlink()
文件类型：filetype()
重命名文件或者目录：rename()
文件截取：ftruncate()

# 实例：目录遍历、目录的复制和删除

/**
 * 目录操作
 * 打开目录>读取目录->关闭目录
 *
 **/
// 打开文件
// 将文件的内容读取出来，在开头加入Hello World
// 
// 将拼接好的字符串写回到文件当中
// 

$file = '/Users/houxiaobao/WWW/demo/hello.txt';

$handle = fopen($file, 'r');

$content = 'Hello World' . fread($handle, filesize($file));

fclose($handle);

$handle = fopen($file, 'w');

fwrite($handle, $content);

fclose($handle);


```

#### 7. 通过PHP函数的方式对目录进行遍历，写出程序
```
// 打开目录
// 读取目录当中文件
// 如果文件类型是目录继续打开目录
// 读取子目录文件
// .
// .
// .
// 如果文件类型是文件，输出文件名称
// 关闭目录

$dirname = '/Users/houxiaobao/WWW/demo/';

function loopDir($dirname)
{
	$res = opendir($dirname);

	while(($file = readdir($res)) !== false)
	{
		$arr[] = $file;
		if ($file != '.' && $file != '..') {
			echo $file."\n";
			if (filetype($dirname. '/'. $file) == 'dir') {
				loopDir($dirname.'/'.$file);
			}
		}
	}
}

loopDir($dirname);

```

#### 8. 简述cookie和session的区别及各自的工作机制，存储位置等，简述cookie的优缺点
```
1. 为什么要使用会话控制技术？
    &： HTTP协议是无状态协议，主要用途就是让用户和服务器之间保持一种连接的标识，可以同时在多个页面之间共享一些信息
    
2. cookie &：存储在客户端浏览器的文件。
    # 名称，值，有效期，存储路径，指定域名，是否http或https
    $ setcookie($name, $value, $expire, $path, $domain, $secure)

    优缺点：
        数据存储在客户端，效率高
        用户有权限修改，安全性低，一些隐私信息不建议使用
        
3. session &：将数据存储在服务器中
    // 使用session
    session_start();
    $_SESSION;
    
    // 清空session
    $_SESSION = [];
    或
    session_destroy();
    
    优缺点：
        安全：存入服务器中
        session文件越来越多，占用服务器资源
    问题：session共享：
        如果在分布式环境中，session是存储在一台服务器重的，其他服务器没办法调用到，这时候需要存储session存储到redis中
    
    传递sessionid的问题
    <?php echo SID; ?>
    
    问题：session信息的存储方式，如何进行遍历
        存储方式：通过函数session_set_save_handler()可以选择存储位置，MySQL、Redis
        遍历：直接遍历$_SESSION数组就可以
```

#### 9. 面向对象
```
PHP的类权限控制修饰符
    继承：
        单一继承：同时只能继承一个类
        使用父类方法，parent::demo();
    多态：
        抽象类的定义：abstract
            如果类中有抽象方法，则类必须定义为抽象类
            如果类中没有抽象方法，则类也可以定义为抽象类
        接口类的定义：interface

常用设计模式：
    工厂模式、单例模式、注册数模式、适配器模式、观察者模式和策略模式
    
构造函数：__construct、如果未声明构造函数，当方法名和类名重复时默认为构造函数
析构函数：__destructor

class Father
{
	function demo()
	{
		echo 1;
	}
}

class Son extends Father
{

	public function demo()
	{
		parent::demo();
		echo 2;
	}
}


$son = new Son();
$son->son();
```

10. 网络协议
```
1. HTTP/1.1中，状态码200 301 304 403 404 500
    1XX：接收请求正在处理
    2XX：接收成功
    3XX：重定向
    4XX：客户端错误，服务器无法处理请求
    5XX：服务器错误，处理请求时错误
    
2. OSI七层模型
    物理层：建立、维护断开物理连接
    数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能
    网络层：进行逻辑地址寻址，实现不同网络之间的路径选择
    传输层：定义传输数据的协议端口号，以及流控和差错校验
            协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
    会话层：建立、管理、终止会话
    表示层：数据的表示、安全、压缩
    应用层：网络服务与最终用户的接口
            协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
            
3. HTTP协议的工作特点和工作原理
    工作特点:
        基于B/S模式
        通信开销小、简单快速、传输成本低
        使用灵活、可使用超文本传输协议
        节省传输时间
    工作原理：
        客户端发送请求给服务器，创建一个TCP连接，指定端口号，默认80，连接到服务器，服务器监听浏览器请求，一旦监听到客户端请求，分析请求类型后，服务器会向客户端返回状态信息和数据内容
    
4. HTTP协议常见请求/响应头和请求方法
    GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE
    GET\POST区别：
    1. 浏览器在后退或者刷新时GET没有变化、而POST会被重新提交
    2. GET可以收藏书签，POST不会
    3. GET可以被浏览器缓存，POST不会
    4. GET请求格式是明文而POST数据是加密的
    5. GET请求长度存在限制，2048长度，而POST不会存在，并且POST支持二进制数据传输，GET不支持
    6. 安全性差，GET参数会保存在浏览器历史或者web服务器当中对所有人可见，而post不会
    
5. HTTPS协议工作原理
    HTTPS是一种基于SSL/TLS的HTTP协议，所有的HTTP的数据都是在SSL/TLS协议封装之上传输的
    
    HTTPS协议在HTTP协议的基础上，添加了SSL/TLS握手以及数据加密传输，也属于应用层协议

6. 常见网络协议含义及端口
    FTP：文件传输协议
    Telnet（端口号：23）：远程登陆端口
    SMTP（端口号：25）：邮件服务器
    POP3（端口号：110）：接收邮件
    HTTP（端口号：80）：超文本传输协议
    DNS（端口号：53）：域名解析服务

    问题：常见的HTTP协议和TCP协议在OSI七层协议中的第几层
        HTTP协议在第七层
        TCP协议在第四层
```

#### 11. Linux考点
```
1. 写出尽可能多的Linux命令
    # 系统安全
    $ sudo、su、chmod、chown、setfacl
        
    # 进程管理
    $ w、top、ps、kill、pkill、pstree、killall
        
    # 用户管理
    $ id、usermod、useradd、groupadd、userdel
        
    # 文件系统
    $ mount、umount、fsck、df、du
    
    # 系统关机和重启
    $ shutdown、reboot
    
    # 网络应用
    $ curl、telnet、mail、elinks
        
    # 网络测试
    $ ping、netstat、host
    
    # 网络配置
    $ hostname、ifconfig
    
    # 常用工具
    $ ssh、screen、clear、who、date
    
    # 软件包管理
    $ yum、rpm、apt-get

    # 文件查找和比较
    $ locate、find
        
    # 文件内容查看
    $ head、tail、less、more
    
    # 文件处理
    $ touch、unlink、rename、ln、cat
        
    # 目录操作
    $ cd、mv、rm、pwd、tree、cp、ls
        
    # 压缩/解压
    $ bzip2/bunzip2、gzip/gunzip、zip/unzip、tar
    
    # 文件传输
    $ ftp、scp
        
    # 系统定时任务
    $ crontab -e 创建定时任务 * * * * * （分 时 日 月 周）
        
    # vim编辑器
        一般模式：删除、复制、粘贴
        切换编辑模式：i、I、o、O、a、A、r、R
        切换命令行模式：:、/、?
    
    # shell基础
        脚本执行方式
        赋予权限，直接执行，例：chmod+x test.sh; ./test.sh
        调用解释器使得脚本执行，例：bash、csh、csh、ash、bsh、ksh等等
        使用source命令操作：source test.sh
        
        编写基础
        开头用#!指定脚本解释器，例如：#!/bin/sh
        编写具体功能

    问题：如何每天0点自动执行脚本
    $ crontab -e 0 0 * * * reboot
```

### MySQl

#### MySQL基础
```
# 请写出下面MySql数据类型表达的意义（int(0)、char(16)、varchar(16)、datetime、text)）
    int：整型类型，长度为0位
    char：定长字符串类型，长度为16位
    varchar：可变长度字符串类型，长度为16位
    datetime：时间日期类型
    text：字符串类型，大文本数据
    
MySQL 数据类型
    整数类型
    TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT
    属性：UNSIGNED
    
    字符串类型
    VARCHAR、CHAR、TEXT、BLOB
    VARCHAR类型用于存储可变长字符串，它比定常类型更节省空间
    VARCHAR使用1或2个额外字节记录字符串长度，列长度小于255字节，使用1个字节表示，否则用2个
    
    日期时间类型
    尽量使用TIMESTAMP，比DATETIME空间效率高
    用整数保存时间戳的格式通常不方便处理
    如果需要存储微妙，可以使用bigint存储
MySqL 基础操作
    MySQL的链接和关闭：mysql -u（用户） -p（密码） -h（主机） -P（端口）
    
MySQL 存储引擎
    InnoDB表引擎
        默认事务型引擎，最重要最广泛的存储引擎，性能非常优秀
        数据存储在共享表空间，可以通过配置分开
        对主键查询的性能高于其他类型的存储引擎
        内部做了很多优化，从磁盘读取数据时自动在内存构建hash索引
        插入数据时自动构建插入缓冲区
        通过一些机制和工具支持真正的热备份
        支持崩溃后的安全回复
        支持行级锁
        支持外键
    MyISAM表引擎
        5.1版本前，MyISAM时默认的存储引擎
        拥有全文索引、压缩、空间函数
        不支持事务和行级锁，不支持崩溃后的安全恢复
        表存储在两个文件，MYD和MYI
        设计简单，某些场景下性能很好

MySQL 锁机制
    表锁是日常开发当中常见的问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题
    
    共享锁（读锁）
        共享的，不堵塞，多个用户可以同时读一个资源，不干扰
    
    排他锁（写锁）
        排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户读取正在写入的资源
        
    锁粒度
        表锁，系统性能开销最小，会锁定整张表，MyISAM使用表锁
        
MySQL 事务处理、存储过程、触发器
    事务处理
        MySQL提供事务处理的表引擎，InnoDB
        服务器曾不管理事务，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱
        
        比如在一个请求中对多个表进行操作，分别有InnoDB、MyISAM的表，这种情况做不成事务处理
    
    存储过程
        为以后的使用而保存的一条或多条MySQL语句的集合
        存储过程就是有业务逻辑和流程的集合
        
MySQL索引
    索引对性能的影响
        大大减少服务器需要扫描的数据量
        大大提高查询速度，降低写的速度、占用磁盘
    MySQL索引的基础和类型
        普通索引：最基本的索引，没有任何约束限制
        唯一索引：与普通索引类似，但是具有唯一性约束，可以空值
        主键索引：特殊的唯一索引，不允许空值
        组合索引：将多个列组合在一起创建索引，可以覆盖多个列
    MySQL索引的创建原则
    
    MySQL索引的注意事项
    
    
    联合索引理解
        单个索引和联合索引的区别
        
        联合索引其实是创建了一个索引，同时作用在多个字段上应用，他的效果缩短查询范围
        
        比如：比如索引为KEY(a,b,c) ,那么这样理解，a是章，b是小节，c是一个段落。
        假如要查询 第一章 第二小节 第三段内容，
        那联合索引索引是先进行【章】扫描，然后在【这一章】里面的扫描【小节】，最后在【这一小节】里面扫描【段落】，会有效缩短扫描范围
        
        而单个索引会先扫描【章】，在扫描【小节】，再扫描【段落】，相对来讲效率会低
    
    like查询，%不能在前，可以使用全文索引
    or、like、字符串类型查询要加引号，索引失效
    

```

#### 检查查询sql慢的方法
```
# 1. 开启慢查询日志，设置查询时间标准，超过则记录日志

# 2. 开启proffiles sql临时表，会查询时开启后所执行过的sql的详情
$ set profiling=1; // 开启查询临时表
$ show profiles; // 查询临时表内容
$ show profile for query [id]; // 查询时间详情

# 3. 检查sql的执行次数
$ show status;

# 4. explain 检查单挑语句sql

@note : 
    1. 查询不必要的列
    2. * 号
    3. 查询不需要的记录，使用limit解决
    4. 多表关联返回全部列，使用指定列
    5. 增加必要索引
    6. 改变合适的数据库和表结构
    7. 分解sql
    8. 避免子查询
    9. UNION ALL 效率高于UNION
    
    不变法则：空间换时间，时间换空间

@note:
    首先定位哪些sql会慢
    然后分析SQL效率
```

#### MySQL高可扩展和高考察点
```
# 简述MySQL分表操作和分区的工作原理，分别说说分区和分表的使用场景和各自优缺点

# 1. 分区表原理
    @ 对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都
      会使用ige独立的表文件
      

    分区表对于客户端，php与mysql交互是不需要改变什么值
    是MySQl对表进行优化，分区，对表进行物理拆分

    @ 创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有我们需要数据的
      分区，这样查询只需要查询所需数据在的分区即可
    
    1. 分区表最多只能有1024个分区
    2. 5。1版本中，分区表表达式必须是整数，5.5可以使用列分区
    3. 分区字段中如果有主键和唯一索引列那么主键列和唯一列都必须包含进来
    4. 分区表中无法使用外键约束
    5. 需要对现有表的结构进行修改
    6. 所有分区都必须使用相同的存储引擎
    7. 分区函数中可以使用的函数和表达式会有限制

# 2. 分库分表原理
    通过一些HASH算法或者工具实现将意涨数据表垂直或者水平进行物理切分
    
    应用场景：
        单表达到百万或者千万
        解决表锁机制
    分表方式
        水平分割
            对表进行分类分割，例：时间、地区，是否常用。
        垂直分割
            把主键和一部分列放到A表，主键和其他列放到B表，比如用户表，用户姓名，账号，密码，级别，特殊字段放到A表，邮箱手机号什么的放到B表

# 3. MySQL的复制原理和负载均衡
    主从复制
        在主库上把数据更改记录到二进制日志binlog
        从库将主库的日志复制到自己的中继日志
        从库读取中继日志中的事件，将其重放到从库数据中
        
    
问题：设定网站的用户数量在千万计，但是活跃用户的数量只有1%，如何通过优化数据库提高活跃用户的访问速度

    分区分表
    根据统计用户活跃度进行分区，常用的用户分到一个区，不常用的分到另外一个区

    分库分表，水平切分方式
```

#### SQL语句的安全性
```
# SQL查询安全方案
    使用预处理语句防sQL注入
    查询错误信息不要返回给用户，将错误记录到日志
# MySQL的其他安全设置
    关闭远程访问数据库权限
    权限管理
    
为什么使用PDO和MySQLi连接数据库会比mysql函数库更加安全
    PDO和MySQLi支持预处理，防止SQL注入
```

#### 框架特性
```
# php框架有哪些
    yaf框架：非常快
        优点：执行效率高、轻量级框架、可扩展性强
        缺点：高版本兼容性差、底层代码可读性差、需要安装扩展、功能单一、开发需要编写大量的插件
    Yii2框架
        优点：结构简单优雅、实用功能丰富、扩展性强、性能高是它最突出的优点
        缺点：学习成本较高
```

#### 算法
```
# 冒泡排序的原理和实现
    
# 算法的概念
    五个特征：有穷性、确切性、输入项、输出项、可行性
# 时间复杂度、空间复杂度
    时间复杂度
        执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n的函数f(n),算法的时间复杂度也因此记做T(n)=O(f(n))
        常数阶：用常数(1)来取代所有时间中的所有加法常数
        线性阶：O(n)
        平（立）方阶：O(n^2)/O(n^3)
        O(log2n)：2的多少次方=n;例：LOG2（8）=3;相当于，2的3次方等于8
    空间复杂度
        算法需要消耗的内存空间，记作S(n)=O(f(n))
        包括程序代码中所占用的空间，输入数据所占用的空间和辅助变量所占用的空间这三个方面
        计算和表示方法与时间复杂度类似，一般用复杂度的渐进性来表示
        
        冒泡排序的元素交换，空间复杂度O(1)
# 常见排序算法
    冒泡排序、直接插入排序、希尔排序、选择排序、快速排序、堆排序、归并排序
    
    冒泡排序
        原理：两两相邻的数进行比较，如果反序就交换，否则不交换
        时间复杂度：最坏(O(n^2))、平均最坏(O(n^2))
        空间复杂度：O(1)
        
    直接插入排序
        每次从无序表中去除第一个元素把它插入到有序表的合适的位置，使有序表仍然有序
        时间复杂度：最坏(O(n^2)), 平均(O(n^2))
        空间复杂度：O(1)
        
    希尔排序
        原理：把待排序额数据根据增量分成几个子序列，对子序列进行插入排序，知道增量为1，直接进行插入排序；
        增量的排序，一般是数组的差个都的一般，再变为原来增量的一般，知道增量为1
       
    选择排序
        原理：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完
        时间复杂度：最坏(O(n^2)), 平均(O(n^2))
        空间复杂度：O(1.)
    
    快速排序
        原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的数据比另外一部分的所有数据都要笑，
        然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归完成
        时间复杂度：最坏(O(n^2)), 平均(O(nlog2n))
        空间复杂度：O(n),平均(O(log2n))
# 常见查找算法
    二分查找
        从数组的中间元素开始，如果中间元素正好是要查找的元素，搜索结束；
        如果某一个特定元素大于或者小于中间元素，则在数组大于或者小于中间元素的那一半查找
        而且跟开始一样从中间开始比较，如果某一步骤数组为空，代表找不到
        时间复杂度：O(log2n),平均O(log2n)
        空间复杂度：迭代(O(1))，递归(O(log2n))
        
    顺序查找
        事件复杂度：最差(O(n))),平均(O(n)))
        空间复杂度：(O(1))
        
    总结：二分查找算法的时间复杂度最差是O(log2n),顺序查找的时间复杂度最差为O(n),所以二分查找法更快，但是递归情况下，二分查找发更小号内容，时间复杂度为O(log2n)
```

#### 数据结构
```
# 请简单描述一下数据结构的特征（stack、heap、list、doubly、linked-list、queue、array(vector)）
1. 数组:最简单而且应用最广泛的数据结构之一
特性：使用连续的内存来存储，数组中的所有元素必须是相同的类型或类型的衍生（同质数据结构）、元素可以通过下标直接访问

2. LinkedList
链表，线性表的一种，最基本、最简单、也是最常用的数据结构
特性：元素之间的关系是一对一的关系（除了第一个和最后一个元素，其他元素都是首尾相接）、顺序存储结构和链式存储结构两种存储方式

3. Stack
栈，和队列相似，一个带有数据存储特性的数据结构
特性：存储数据先进后出，栈只有一个出口，只能从栈顶部增加和移除元素

4. Heep
堆，一般情况下，堆叫二叉堆，近似完全二叉树的数据结构
特性：子节点的键值或者索引总是小于它的父节点、每个节点的左右子树又是一个二叉堆、根节点最大的堆叫最大堆和大根堆、最小的叫最小堆或者小根堆

5. list
线性表，有零个或多个数据元素组成的有限序列
特性：线性表是一个序列、0个元素构成的线性表是空表、第一个元素无先驱、最后一个元素无后继、其他元素都只有一个先驱和后继、有长度，长度是元素个数，长度有限

6. doubly-linked-list
双向链表
特性：每个元素都是一个对象，每个对象有一个关键字key和两个指针(next和prev)

7. queue
队列
特性：先进先出（FIFO）、并发中使用、可以安全将对象从一个任务传给另一个任务

8. set
集合
特性：保存不重复元素

9. map
字典
特性：关联数组、也被叫做字典或者键值对

10.graph
图
特性：通常使用邻接矩阵和邻接表表示、前者易实现但是对于稀松矩阵会浪费较多空间、后者使用链表的方式存储信息但是对于图搜索时间复杂度较高

问题：
    用PHP实现一个双向队列
    array_shift
    array_unshift
    array_pop
    array_push
```

#### 逻辑算法考点
```
问题：
    1,1,2,3,5,8,13,21,34....求第30位的数是多少，请用伪代码描述其实现方法
    解答：
        $arr = [1,1];
    
        for ($i=0; $i < 30; $i++) { 
            $arr[$i+2] = $arr[$i] + $arr[$i+1];
        }


    请写一个函数，实现以下功能：字符串“open_door”转换成“OpenDoor”、“make_by_id“转换成”MakeById“
    解答：
        function strex(string $str){
            $arr = explode('_', $str);
            $ret = '';
            foreach ($arr as $value) {
                $ret .= ucfirst($value);
            }
            return $ret;
        }
```

#### 模拟内置函数实现
```
问题：
    不使用PHP函数，用方法写一个反转字符串的话函数
    解答：
        function str_rev($arr){
            // 求长度
            for ($i=0;true;$i++) { 
                if (!isset($arr[$i])) {
                    break;
                }
            }
        
            $ret = '';
            for ($j=$i-1; $j>=0; $j--) { 
                $ret .= $arr[$j];
            }
        
            return $ret;
        }
    
    实现数组合并函数
    解答：
        // 实现数组合并函数
        function array_mer(){
            $arr = func_get_args(); // 获取所有的动态参数
            var_dump($arr);
            $new_arr = [];
        
            foreach ($arr as $value) {
                foreach($value as $val){
                    $new_arr[] = $val;
                }
            }
        
            return $new_arr;
        }
```

#### 高并发和大流量解决方案考点
```
1. PHP如何解决网站大流量与高并发问题？
    高并发架构相关概念
    QPS
        每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数（指HTTP请求）；
        
    响应时间
        从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间
    
    吞吐量
        单位时间内处理的请求数量
    
    什么是高并发
        高并发：在某个时间点有多少个访问同时到来
        
    什么是高并发系统
        通常如果一个系统的日PV在千万以上，有可能是一个高并发系统
        
    PV
        综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量
        同一个人浏览一个网站为1个PV
    
    UV
        即一定时间范围内相同方可多次访问网站，只计算为1个独立访客
        
    带宽：峰值流量和页面平均大小
    
    测试工具：ab
    $ ab -c 100 -n 5000
        -c 并发数100
        -n 访问测试5000
    
    QPS达到50，小型网站，一般服务器就可以搞定
    
    QPS达到100
    假设关系型数据库的每次请求在0.01秒完成
    假设单页面只有一个SQL查询，那么100QPS意味着1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次
    方案：数据库缓存层、数据库的负载均衡
    
    QPS达到800
    假设我们使用百兆带宽，意味着网站出口的实际带宽是8M左右
    假设每个页面只有10k，在这个并发条件下，百兆带宽已经吃完
    方案：CDN加速、负载均衡
    
    QPS达到1000
    假设使用Memcache缓存数据库查询数据，每个页面堆Memcache的请求远大于直接对DB的请求
    Memcache的悲观并发数在2W左右，但有可能在之前内网带宽已经吃光，表现出不稳定
    方案：静态HTML缓存
    
    QPS达到2000
    这个级别下，文件系统访问锁都成为了灾难
    方案:做业务分离，分布式存储
    
    
    优化案例：
        流量优化：防盗链处理，[把一些恶意请求进行禁止]
        
    前端优化：
        减少HTTP请求：css，js，图片，进行合并请求并缓存到本地
        异步请求：不要一次性请求数据
        启用浏览器缓存和文件压缩
        CDN加速，把前端文件，资源放入CDN当中，就近存储
        建立独立资源服务器，或者图片服务器。
        
    服务端优化
        页面静态化，直接将PHP文件转化成HTML静态页面，减少服务器压力
        并发处理
        队列处理
        
    数据库优化
        数据库缓存Redis、Memcache、MongoDB
        分库分表、分区操作
        读写分离
        负载均衡
    
    Web服务器优化
        负载均衡（Nginx反向代理）
```

#### Web资源防盗链
```
盗链概念
    盗链是指在自己的页面上展示一些并不在自己服务器上的内容
    获得他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容
    常见的是小站盗用大战的图片、音乐、视频、软件等资源
    
    
防盗链概念
    防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效
    1. 通过Referer或者签名，网站可以检测目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。
    一旦检测到来源不是本站即进行组织或者返回指定的页面
    Nginx 模块ngx_http_referer_module  用于阻挡来源非法的域名请求
    Nginx指令valid_referers,全局变量$invalid_referer
    $ valid_referers none | blocked | server_names | string
    note : "Referer"来源头部为空的情况
    blocked: "Referer" 来源头部不为空，但是里面的值被代理或者防火墙删除了，不已http或https开出
    server_name: 来源头部信任的域名地址
    
    location~.*\.(git|jpg|png|flv|swf|rar|zip)$
    {
        valid_referers none blocked imooc.com *.imooc.com;
        # 不合法$invalid_reerer=1
        if($invalid_reerer)
        {
            # return 403;
            rewrite ^/http://www.baidu.com;
        }
    }
    
    有些自定义head头信息可以伪造referer则避免不了
    
    
    2. 通过计算加密签名的方式，判断请求是否合法，如果合法则显示，否则返回错误信息。
        使用第三方模块HttpAccteeKeyModule实现Nginx防盗链
        accesskey on|off 模块开关
        accesskey_hashmethod md5 | sha-1 签名加密方式
        accesskey_arg GET参数名称
        accesskey_signature 加密规则
        
        localtion ~ .*\.(git|jpg|png|flv|swf|rar|zip)$
        {
            accesskey_on;
            accesskey_hashmethod md5;
            accesskey_arg "key";
            accesskey_signatrue "json$remote_addr";# 字符串+客户端ip
        }
```

#### HTTP请求
```
性能黄金法则
    只有10%-20%的最终用户响应时间花在接收请求的HTML文档上，剩下的80-90%时间花在HTML文档所引用的所有组件
    （图片，script，css，flash等等）进行的HTTP请求上

如何改善
    减少组件数量，减少HTTP请求

HTTP连接产生的开销
    域名解析--TCP连接--发送请求--等待-下载资源-解析时间
    
DNS缓存

HTTP1.1协议是串行请求

图片地图
    将五个导航栏图片合并成一张图片，以位置定位超链接
  
```

#### 浏览器缓存
```
HTTP的三类缓存
1. (Status Code：200 from disk cache) or (Status Code：200 from memry cache)
    Memory Cache，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。 
    disk Cache，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。它与memoryCache最大的区别在于，当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。 

2. 304 Not Modified：协商缓存
    浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端，
    如果服务器端数据没有改变浏览器从本地缓存响应，返回304

3. 200 ok
    不适用缓存，服务器数据完整返回。
```

#### CDN
```
1. 什么是CDN
    内容分发网络，尽可能避开互联网上会影响速度的因素，使传输更稳定。
    
    例：北京用户访问深圳服务器，因为地域问题网络访问速度较慢，如果添加北京访问节点，那么只需要访问北京的节点就可以，提高速度
    
    影响元素：流量大小、负载状况、距离、响应时间等综合实信息
    
2. 使用CDN的优势
    本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度
3. CDN的工作原理
    传统访问流程
        1. 用户在浏览器输入域名发起请求
        2. 解析域名获取服务器IP地址
        3. 根据IP地址找到对应的服务器
        4. 服务器响应并返回数据
    使用CDN访问
        1. 用户发起请求
        2. 只能DNS的解析（根据IP判断地理位置、接入网型、选择路由最短和负载最轻的服务器）
        3. 取得缓存服务器IP
        4. 把内容返回给用户（如果缓存有）
        5. 向源站发起请求
        6. 将结果给用户
        7. 将结果存入缓存服务器 
4. CDN的适用场景

5. CDN的实现
    Nginx，大厂自带服务
```

#### 独立图片服务器
```
为什么独立服务器
    1. 耗费资源的图片服务分离出来，减少Web服务器的I/O负载
    2. 能够专门对图片服务器进行优化，针对性设置缓存，减少带宽成本，提高速度

采用独立域名
    1. 同一域名下浏览器的并发连接数有限制，突破浏览器连接数的限制
```

#### 动态语言静态化
```
什么是动态语言静态化
    将现有PHP等冬天语言的逻辑代码生成为静态HTML文件，用户访问动态脚本重定向到静态HTML文件的过程
    不经常更新的HTML页面
为什么要静态化

静态化实现方式
```

#### 动态语言并发
```
什么是进程、线程、协程
    进程：是一个执行中的程序
    阻塞：也成为等待或者睡眠状态，一个进程正在等待某一事件发生而暂时停止运行，这时把处理机分配给进程也无法运行，称阻塞进程
    
    线程：线程是进程中的实体

什么是多进程、多线程
    多线程
    同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这就是多进程
    
    多线程
    线程就是把一个进程分为很多片，每一片都可以是一个独立的流程
    与多进程的区别就是只会使用一个进程的资源，线程间可以直接通讯
同步阻塞模型

异步非阻塞模型

PHP并发编程实践
```

#### MySQL优化
```
数据表数据类型优化
    int类型选择
        ip地址可以存整型
        tinyint 年龄
        smallint 较小数字
        bigint 较大数字
    char类型
        char 手机号码，身份证号码，md5密码
        varchar
索引优化
    like查询%在前索引会失效
    一些要执行全表扫描的数据不需要添加索引,例：100条数据，大多数的查询是查询98条那么就不用添加索引
    or 前用到索引而后面用不到索引，索引失效
    字符串类型 进行整型查询索引失效
    
SQL语句优化
    分解关联查询
    优化子查询
    优化group by 
    优化limit 和 union
    
存储引擎优化
    尽量使用InnoDB存储引擎
    支持事务
    支持外键
    使用独立表空间
    行级锁
    
数据表结构设计优化
    分区操作
    分库分表
    
数据库服务器架构的优化
    主从复制
    读写分离
    双主热备
    负载均衡
    
    binlog日志
    中继日志
```


#### Web服务器的负载均衡
```
七层负载均衡的实现
    配置Nginx负载均衡，反向代理轮询请求 多台服务器实现负载均衡
    可配置权重：weight
    

    Nginx的proxy是它一个很强大的功能
    能够自动提出工作不正常的后端服务器
    配置简单灵活
    上传文件使用异步模式
    支持多种分配策略，可是分配权重，分配方式灵活
    
    Nginx负载均衡
        内置策略、扩展策略
        内置策略：IP Hash、加权轮询
            加权轮询：
            首先将请求都分给高权重的机器，知道该机器的权值降到了比其他机器低、才开始将请求分给下一个高权重的机器
        
            IP Hash策略：
            Nginx内置的另一个负载均衡的策略，流程和轮询很类似，知识其中的算法和具体的策略有些变化
            
        扩展策略：fair策略、通用hash、一致性hash
            根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流
四层负载均衡的实现

```

#### 优化方案
```
流量优化，防盗链处理
前端优化，浏览器缓存，数据压缩，前端CDN加速，独立图片服务器
服务端，实现动态语言静态化，并发处理
数据层：数据缓存，MySQL优化，web服务器负载均衡
```

##### 以读写模式打开文件 "FILE.txt"的正确方法是（ ）

```
fopen("FILE.txt","r+");


'r'    只读方式打开，将文件指针指向文件头。
 
'r+'    读写方式打开，将文件指针指向文件头。
 
'w'    写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
 
'w+'    读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
 
'a'    写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
 
'a+'    读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
 
'x'    创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。
 
'x+'    创建并以读写方式打开，其他的行为和 'x' 一样。
```

##### HTTP请求信息由3部分组成： 
```
1. 请求方法URI协议/版本 
2. 请求头(Request Header) 
3. 请求正文
```

##### PDO中一共提供了三种不同的错误处理模式
```
① PDO::ERRMODE_SILENT:不报错误
② PDO::ERRMODE_WARNING:以警告的方式报错
③ PDO::ERRMODE_EXCEPTION：以异常的方式报错
```

